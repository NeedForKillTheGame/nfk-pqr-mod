<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
	<!-- Created by TopStyle Pro Trial Version - www.bradsoft.com -->
	<title>Введение в структуру PQR Mod [PQR Mod SDK]</title>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>

<body>
<div class="contentbloc">
<h3>Введение в структуру PQR Mod</h3>
<div class="newstext">
<h4>Термины и условные обозначени</h4>
<p>PQR Mod позволяет подключать несколько разных ботов. Любой бот реализуется в виде бибилиотки bot.dll. Когда вы подключаете несоклько ботов используя PQR Mod, все эти bot.dll вы переименовываете в файлы с разными именами: xbot.dll, napbot.dll, defbot.dll ... Далее в тексте, всех внешних ботов подключаемых к PQR Mod я буду называть <em>внешними bot.dll</em>, хотя в реальности файлы имеют другие имена.</p>
<p>Мод написан на языке С++ поэтому дальнейшее его описание будет вестись в терминах этого языка. Например, в Delphi различают <em>процедуры</em> и <em>функции</em>; в С++, вне зависимости от наличия возвращаемого параметра, подпрограмму называют <em>функцией</em>.</p>

<h4>Реализация мода на C++</h4>
<p>BOT.dll для NFK может как получать сообщения, так и отправлять их. Получение сообщений реализуется через экспортируемые функции. Т.е. бибилиотека предоставляет набор функций с заранее оговоренными именами и NFK.exe вызывает их по необходимости. Для того чтобы послать сообщение в NFK.exe, нужно вызывать функции которые регистрируются в бибилиотеке как указатели на код NFK.exe.</p>

<p>Основная проблема при написании мода на языке C++ состояла в различном механизме передачи параметров в функциях языков С++ и Delphi. Поэтому был разработан промежуточный интерфейс C++ <-> Delphi. Это такая bot.dll написаная на Delphi, которая принимает выозовы из pqrmod.dll (язык С++), преобразует параметры и передаёт сообщение в NFK.exe. И наоборот, все сообщения из NFK.exe приходят в bot.dll, там преобразуются параметры и далее вызывается необходимая функция в pqrmod.dll</p>

<p>Хорошей идеей оказалось реализовать на этом же промежуточном интерфейсе так называемый Multibot - подключение нескольких внешних bot.dll. Действительно, почему бы перед преобразованием параметров и передачи их в PQR Mod не передать их в другие bot.dll. Таким образом одно сообщение пришедшее из NFK.exe (например EVENT_MainLoop) рассылается в несколько внешних bot.dll и в pqrmod.dll</p>

<p>В коде bot.dll принята условная запись названий функций:<br>
<em>P_DLL_</em> функции промежуточного интерфейса обеспечивающие передачу сообщений C++ -> Delphi (pqrmod.dll -> NFK.exe)<br>
<em>C_DLL_</em> функции импортируемые из pqrmod.dll, в них передаются сообщения изначально пришедшие из NFK.exe<br>
<em>EXTERNAL_DLL_</em> функции импортируемые из других внешних bot.dll реализующие стандартный BOT API<br>
<em>EXTERNAL_DLL_PMA_</em> функции импортируемые из других внешних bot.dll реализующие стандартный PQR Mod API - набор расширений предоставляемых разработчикам ботов если их бот будет запущен под PQR Mod.</p>

<h4>Модульный принцип программирования</h4>
<p>Основной код PQR Mod написан на C++. Проект разбит на модули. Каждый модуль выделен в отдельный .cpp файл и имеет свой заголовочный .h файл. Это позволяет легко ориентироваться в коде. Основной файл: pqrmod.cpp - реализует экспортируемые функции. Т.е. все сообщения из NFK.exe, пройдя через промежуточный интерфейс, попадают именно сюда, в модуль pqrmod.cpp. Подробно исследовав это файл можно представить себеб общий алгоритм работы мода. Будет понятно какой модуль и в каких ситуациях вызывается. Однако и между модулями есть некоторое сцепление, которое я постарался свести к минимуму. Если бы модули постоянно использовали функции друг друга по каждой мелочи, получился очень запутаный код и не было бы никакого резона разделения программы на модули.</p>
<p>Итак каждый модуль состоит из 2-х файлов с одинаковым именем и расширениеи .cpp или .h . Вот список модулей и краткое их описание:
<ul>
<li><strong>animaiton</strong> анимационные эффекты при при появлении меню и окон</li>
<li><strong>autorecord</strong> автоматическая запись демок</li>
<li><strong>common</strong> набор вспомагательных функций, используется повсеместно</li>
<li><strong>config_manager</strong> загрузка и сохранение конфигов</li>
<li><strong>console</strong> обаработка консольных команд, вывод сообщений</li>
<li><strong>dll_register</strong> импортирует из функции промежуточного интерфейса из bot.dll</li>
<li><strong>graph</strong> вывод графических иллюстраций (например лого PQR Mod)</li>
<li><strong>hud</strong> вывод HUD - интерфейс с жизнями, патронами и проч.</li>
<li><strong>input</strong> следит за перемещениями мыши, нажатиями клавиш клавиатуры и генерирует соотв. сообщения</li>
<li><strong>main_menu</strong> главное меню</li>
<li><strong>map</strong> все действия при смене и загрузке карты на этом модуле</li>
<li><strong>menu</strong> базовые классы для реализации каскадного меню управляемого мышью и клавиатурой</li>
<li><strong>messages</strong> вывод сообщений на экран (не на кнсоль). Например сообщение "You fragged ..."</li>
<li><strong>multibot</strong> возможность подулючать несколько внешних bot.dll . Как я уже писал ранее, ядро Multibot находится в промежуточном интерфейсе, в файле bot.dll написанном на Delphi. В этом модуле создан пользовательский интерфейс: обработка консольных команд, управление через меню.</li>
<li><strong>mw_hook</strong> поддержка дополнительных кнопок мышек серии Logitech MX</li>
<li><strong>player</strong> реализация класса игрка и всех сервисных функций связаных с ним</li>
<li><strong>pm_api</strong> PQR Mod API - расширения предоставляемые разработчикам ботов</li>
<li><strong>pqrmod</strong> основной модуль</li>
<li><strong>ruleset</strong> установка стандартных турнирных правил</li>
<li><strong>ShevList</strong> класс двунаправленого списка, используется практически во всех модулях</li>
<li><strong>teamhelp</strong> всяческие утилиты помогающие в тимплее</li>
<li><strong>tools_menu</strong> меню с настройками различных модулей</li>
<li><strong>types</strong> описание типов для совместимости с Delphi</li>
</ul>
Далее, каждый из этих модулей будет рассмотрен более подробно.</p>
<h4>Структура модуля</h4>
<p>Модули должны иметь какой-то интерфейс взаимодействия с основной программой и между собой. Часть модулей имеет процедурный интерфейс - т.е. содержит процедуры типа <em>GRAPH_EVENT_MainLoop()</em>. Другая часть имеет объектно ориентированый интерфейс, т.е. модуль представлен объектом, который принимает сообщения, например: <em>Console.EVENT_ConsoleCommand(char* str)</em>. Однако и те и другие в основе имеют набор функций, названия которых знакомы всем разработчикам ботов. Ибо большенство сообщений это сообщения приходящие из NFK.exe, и интерфейс их получения продиктован стандартным BOT API.</p>
<p>Каждый модуль в своём заголовочном файле подуключает <em>pqrmod.h</em> - это общий для всех заголовочный файл, который в свою очередь подключает такие часто используемые модули как ShevList, dll_registed и др. Если для данного модуля необходима связь с каким-то "не общим" для всех модулем, это реализуется подключением нужного заголовочного файла из .cpp. Например, модуль multibot имеет интерфейс управления в виде графического меню. Для доступа к базовым классам меню, в первых строках multibot.cpp указана инструкция <em>#include "menu.h"</em>. Таким образом, просматривая код, можно чётко установить все сцепления между модулями.</p>
</div>
</div>
</body>
</html>
