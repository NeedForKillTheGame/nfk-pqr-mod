<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>
	<title>Работа с консолью [PQR Mod SDK]</title>
	<link rel="stylesheet" type="text/css" href="main.css">
</head>

<body>
<div class="contentbloc">
<h3>Работа с консолью</h3>
<div class="newstext">
<h4>Введение</h4>
<p>
Модуль console введён для работы с консолью. Давайте определим задачи, которые должен рашать этот модуль.
<ol>
<li>Обработка консольных команд вводимых пользователем</li>
<li>Обработка сообщений приходящих на консоль</li>
<li>Вывод сообщений на консоль</li>
</ol>
Пункты 1 и 3 реализованы на данный момент в PQR Mod. Для второй задачи пока не ясны практические цели. Хотя некоторые задумки проглядываются.
</p>
<h4>Вывод на консоль</h4>
<p>Начнём с последнего и самого простого пункта. Вывод сообщения на консоль осуществляется функцией AddMessage(s: string) - это внутрення функция NFK.exe. Естественно вызвать из С++ модуля (pqrmod.dll) напрямую её нельзя из-за несоответствия типов char* и string. Как всегда на помощь приходит промежуточный интерфейс - bot.dll . Теперь в С++ программе вызов выглядит как fnP_DLL_AddMessage(char* str). Однако, это прямой вывод на консоль некой текстовой переменной. А что если вывести надо число? А если какой-то адрес памяти и проч.? В этом случае все вспомагательные действия по переводу параметров в строку и конечный вызов fnP_DLL_AddMessage ложатся на модуль console. Модуль имеет объктный интерфейс. Т.е. сущетвует обхект CConsole Console , который инкапсулирует в себе множество методов модуля. Для вывода строки предусмотрено 2 метода:
<ul>
<li><em>Console.print(char* str)</em> - выводит текстовую строку</li>
<li>C<em>onsole.printf(char* format, ...)</em> - выводит форматированый текст</li>
</ul>
Последняя функция знакома пользователям Си. Это функция с переменным числом параметров которая в качестве первого параметра принимает формат строки, а далее идут параметры переменные любых типов, которые должны в эту строку войти (на Delphi такую функцию точно не напишешь :)). Полнностью аналогична стандартной Си функции <em>printf</em>, можно воспользоваться хелпом к Си, чтобы понять, как обращаться с этой функцией.
</p>
<h4>Обработка консольных коман</h4>
<p>
Давайте разберёмся в общих принципах работы с консолью NFK. Легко заметить, что все конмады можно разделить непосредственно на <strong>команды</strong> и на <strong>переменные</strong>. Основное отличие в том, что переменная хранит в себе какое-то значение и выводит его значение, елси написать имя переменной без дополнительных параметров. Например, <em>timelimit</em> это переменная. Она хранит в себе число. Если написать в консоли timelimit и нажать enter, то будет выведено текущее значение. <em>exec</em> это команда в чистом виде. Выполненая с параметром, она загружает конфиг указаный в параметре. Если просто написать exec и нажать enter, то получим справку по использованию этой команды. exec не хранит в себе никаких данных, она не помнит имя последнего загруженого конфига.
</p>
<p>
Если пойти дальше, то можно заметить, что переменные NFK, так же как и переменные язоков программирования, обладают свойством типа. Есть числовые переменные (timelimit, fraglimit), есть строковые переменные (name, model), есть даже переменные типа boolean (ch_hudVsible, r_altgenades) в которых условно принято 1 = true, 0 = false. В NFK нет переменных в виде числа с плавающей точкой или множества enum. Однако PQR Mod не останавливается на достижениях NFK, поэтому в него потенциально заложена возможность работы с такими типами переменных.
</p>
<p>
Реализация переменных базируется на наследовании классов. Базовый класс это класс <em>команды</em>:
<pre class=code>class c_cmd//Команда
{
protected:
	char* name;
	char* string;
public:
	c_cmd(char *n, char *s, fnOnExecute fn=NULL);
	
//Возвращает TRUE, если парамер str эквивалентен полю string
	bool cmp(char *str);
	
	virtual void set_value(char *new_val);
	
//Вызывется перед изменением значения переменной или при вызове команды
	fnOnExecute OnExecute;
};</pre>
От него наследуются классы переменных разных типов:
<pre class=code>class c_var_int : public c_cmd //Переменная типа int
{
	int val;
	int default_val;
	int min_val;
	int max_val;
public:
	c_var_int(char* n, char* s, int d, int mn, int mx, fnOnExecute fn=NULL);
	int value() {return val;}
	void set_value_int(int new_val_i); 
	void set_value(char *new_val);
	void print();
};

class c_var_float : public c_cmd //Переменная типа float
{
	float val;
	float default_val;
	float min_val;
	float max_val;
public:
	c_var_float(char* n, char* s, float d, float mn, float mx, fnOnExecute fn=NULL);
	float value() {return val;}
	void set_value_float(float new_val_f); 
	void set_value(char *new_val);
	void print();
};

class c_var_string : public c_cmd //Переменная типа string
{
	char* val;
	char* default_val;
public:
	c_var_string(char* n, char* s,const char* d, fnOnExecute fn=NULL);
	char* value() {return val;}
	void set_value(char *new_val);
	void print();
};

class c_var_bool : public c_cmd //Переменная типа bool
{
	bool val;
	bool default_val;
public:
	c_var_bool(char* n, char* s, bool d, fnOnExecute fn=NULL);
	bool value() {return val;}
	void set_value_bool(bool new_val); 
	void set_value(char* new_val);
	bool togle(); //Делает инверсию переменной и возвращает новое значение
	void print();
};</pre>
<p>
Почему для каждого типа переменной отдельный класс? Не проще было бы воспользоваться шаблонными классами для указания типа? - спросят меня знатоки С++. Замечу, что консольные переменные разных типов различаются не только по типу хранимых данных, но и по свойствам и реализуемым методам. Так, например, невозможно отнести метод togle() (инверсия булева значения) ни к какой другой консольной переменной, кроме как к переменной типа boolean. И таких отличий достаточное количество, так что введением одного шаблонного класса здесь не обойтись.</p>
<p>Большенство имён функций и членов данных этих классов говорят сами за себя. Подробнее, когда какой метод вызывается я рассмотрю чуть позже, после описания основного класса модуля.</p>
<pre class=code>typedef Item<c_cmd*> Item_c_cmd;

class CConsole
{
	List<Item_c_cmd> ListCMDs;
	ListStrings SendOnNextFrame;
	ListStrings SendOnThisFrame;
public:
    void RegisterCMD(c_cmd* c);
	 
//Возвразщает указатель на конс. переменную по полю string
	c_cmd* FindVarByString(char* s);
	
	void ParseAlias(char* str);
	void RegisterConsoleCommands();
	void EVENT_MainLoop();

//Принимает консольную команду из NKF.exe
	bool EVENT_ConsoleCommand(char *s1); 

//Отправляет консольную команду в NFK.exe
	void SendConsoleCommand(char *str);
	void SendConsoleHCommand(char *str); 
	void SendConsoleCommandOnNextFrame(char *str);

//Выводит сообщение на консоль
	void printf (const char *fmt, ...);
	void print (char* str);
};

extern CConsole Console;
</pre>
<p>Алгоритм работы модуля таков. Все консольные переменные и конмады, а это объекты классов производных от класса <em>c_cmd</em>, хранятся в списке <em>ListCMDs</em>. Когда пользователь набирает в консоли команду или имя переменной, возможно даже с параметрами, вся строка попадает в PQR Mod в интерфейсную функцию <em>DLL_EVENT_ConsoleCommand</em>. Далее эта строка передаётся модулю console путём выозова <em>Console.EVENT_ConsoleCommand(str)</em>. Вот тут происходит самое интересное:
<pre class="code">
//Фрагмент CConsole::EVENT_ConsoleCommand (файл console.cpp)
	char* p;
	//Вычленяем из принятой строки первое слово до пробела
	p = strtok(s," "); 
	
	if (ListCMDs.size()!=0) //Ищем соответствующую команду
	{
		ListCMDs.top();
		do
		{
			if (ListCMDs.cur()->d->cmp(p))
			{
				p = strtok(NULL,"\n");
				ListCMDs.cur()->d->set_value(p);
				return true;
			}
		}
		while (ListCMDs.next());
	}

</pre> Из строки вычленяется первое слово до пробела. Это и есть консольная команда или имя переменной. В цикле осуществляется обход по списку команд и переменнх ListCMDs и ищется объект у которого поле <em>char* string</em> хранится введённое слово. Допустим пользователь ввёл существующую команду PQR Mod, и она была найдена в этом списке. Из введённой пользователем строки вычленяется всё, что идёт после имени консольной команды и пробела и передаётся в функцию <em>set_value(char* str)</em>. Вообще говоря, после имени команды может ничего и не следовать, в этом случае передастся NULL. Каждый тип консольной переменной по своему должен обрабатывать параметры идущие за именем и сохранять их в поле данных. Кроме того, если это была "команда", то сохранять какое либо значение вообще не нужно. Здесь использован удобный механизм С++ - <strong>виртуальные функции</strong>. Действительно, заранее было объявлено, что список ListCMDs содержит в себе указатели на объкты типа c_cmd - т.е. консольные "команды". Одноко в реальности там храняться и переменные всех типов (это возможно, т.к. классы переменных являются производными c_cmd). Когда происходит вызов <em>ListCMDs.cur()->d->set_value(p)</em>, программа как бы сама определяет реальный тип данного обхъекта и вызывает соответствующую функцию set_value. Для консльной переменной типа c_var_int будет вызвана функция <em>c_var_int::set_value(char* str)</em>, а для консольной переменной логического типа будет вызвана <em>c_var_bool::set_valiue(char* str)</em>. Это стало возможным благодаря объявлению фукнции set_value с ключевым словом <em>virtual</em> в базовом классе c_cmd. Кстати, в Delphi нет механизма реализации виртуальных функций, как и функций с переменным числом параметров, что очевидно далает решение данной задачи более трудоёмким и некрасивым.</p>
<p>Теперь подробнее разберём саму функцию set_value. Сначала она проверяет значение указателя <em>OnExecute</em> на существование. Это переменная процедурного типа - указатль на внешнюю функцию, обработчик данной переменной. Действительно, некоторые консольные переменные могут изменять своё значение, но используется это значение не сразу. Так, например, перменная timelimit. Её значение используется в основном цикле программы и сравнивается с текущим счётчиком времени. С другой стороны, бывают переменные, изменение которых требует немедленной реакции, например mw_hook. Это переменная логического типа. Значени 1 - включает поддержку дополнительных кнопок Logitech MX, 0 - выключает. Ни в каком цикле это значение не используется и ни с чем не сравнивается. Сразу после включения или выключения необходимо установить или снять хук на нажатия доп. кнопок мыши. Очевидно, здесь потребуется уникальнй обработчик события "переменная изменена". OnExecute как раз указывает на функцию обработчик. У большенства консольных переменных этот указатьель NULL - т.е. внешнего обработчика нет. В этом случае за изменение значения перменной отвечает стандартный код, который переводит значение из текстового вида в требуемый тип, сравнивает с ограничениями (у переменных бываю mix и max значени) и выводит сообщение об успешном или неуспешном изменении текущего значения на консоль. Вот общий план функции set_value:
<pre class="code">void c_var_<em>тип</em>::set_value(char* new_val)
{
//Внешняя функция обработки смены значения вместо стандартной
	if ( OnExecute != NULL ) {OnExecute(new_val);return;} 

	if (new_val!=NULL && strlen(new_val)>0) //Проверяем, не пуст ли параметр введённый пользователем после имени переменной
	{
		//Переводим строку new_val в переменную нужного типа
		//Проверяем ограничения
		//Сохраняем новое значение, если всё ok
		//Выводим сообщение на консоль
		return; //завершение работы функции
	}
	//Если передаваемый параметр был пуст, выодим текущее значение
	print();</pre>
</p>
<p>
С переменными разобралиcь, а что делать с "командами"? Команда не хранит в себе никакого значени и не может иметь стандартного обработчика. У команды должен быть инициализирован указатель на функцию обработчик OnExecute. Функция set_value в случае команды выглядит очень просто:
<pre class=code>void c_cmd::set_value(char *p)
{
	//Команда не может сменить своего значени, он его не имеет
	//просто вызываем внешний обработчик
	if (OnExecute!=NULL) OnExecute(p); 
}</pre>
</p>
<p>Теперь любой другой модуль может создавать свои команды и переменные. Вся работа по их определению и вызову нужных функций ложится на модуль console. Для общности и аккуратности в модулях, все консольные комады и переменне инициализируются в функциях с именем RegisterConsoleCommands(). Там же происходит регистрация команд в NFK.exe, чтобы они стали доступны по нажатию tab. Вот пример инициализации команд модуля multibot:
<pre class=code>void CMultibot::RegisterConsoleCommands()
{
	//Регистрируем консольные команды внутри PQR Mod
	mb_activebot = new c_var_int("mb_activebot","mb_activebot",-1,-1,16,mb_activebot_OnChange);
	c_cmd* activebot = new c_cmd("activebot","activebot",mb_activebot_OnChange);
	c_cmd* mb_list = new c_cmd("mb_list","mb_list",CMD_mb_list);
	c_cmd* mb_on = new c_cmd("mb_on","mb_on",CMD_mb_on);
	c_cmd* mb_off = new c_cmd("mb_off","mb_off",CMD_mb_off);
	
	//Регистрируем консольные команды в NFK.exe
	fnP_DLL_RegisterConsoleCommand("mb_activebot");
	fnP_DLL_RegisterConsoleCommand("mb_list");
	fnP_DLL_RegisterConsoleCommand("mb_on");
	fnP_DLL_RegisterConsoleCommand("mb_off");
} 
</pre>
Вызов функций RegisterConsoleCommands() всех модулей происходит при старте NFK из основного модуля pqrmod.cpp, который в свою очередь получает сообщение о старте игры от bot.dll, которая получает это сообщение из NFK.exe. Всё очень просто и логично!</p>
<p>Основы работы с консолью изложены в этом документе, более подробную работу отдельных функций можно разобрать по исходному коду и комментариям, которые в нём повсюду.</p>
</body>
</html>
